/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.facebook.puzzles.dinoisland.thrift;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Dinosaur {

  /**
   * Dinosaur Island service
   * 
   * This is the API used by clients to interact with the Dinosaur Island
   * server. Functions have two attributes, whether they are actual game
   * functions which cost calories to use, and whether they take up a dinosaur's
   * turn, causing that connection thread to sleep until the next game turn.
   * 
   * All dinosaurs have two resources, their size and their available calories.
   * In addition, all dinosaurs have an individual lifespan before that
   * particular instance of the dinosaur will die of old age. In order for your
   * species to survive and score points, it must eventually lay eggs.
   * 
   * Should your dinosaur not have enough calories to perform a given action, it
   * will die of starvation. If your dinosaur simply idles, it will eventually
   * die of old age.
   * 
   * Eventually, your species time limit will expire, and all instances of your
   * dinosaur species will die off at the same time. One of your client(s) will
   * call an action API and the GameOverException will be returned, informing you
   * that your species died off, what your high score is, and whether your
   * species scored high enough to "solve" the puzzle, and what the top 10 scores
   * are for this island.
   */
  public interface Iface {

    /**
     * Register Client
     * 
     * Costs calories: No
     * Uses up turn: No
     * 
     * This function must be the very first thing called by the first client that
     * connects to the Dinosaur Island server. This function is slightly
     * different from the instructions on the Public Thrift Server, but serves an
     * identical purpose. In addition to the required email, it also requires
     * a string of what to display in the high score table should your species
     * rank in the top 10, as well as a chosen dinosaur type (herbivore or
     * carnivore).
     * 
     * @param email
     * @param highScoreName
     * @param type
     */
    public RegisterClientResults registerClient(String email, String highScoreName, int type) throws AlreadyRegisteredException, TException;

    /**
     * Hatch an egg (take over a previously laid egg)
     * 
     * Costs calories: No
     * Uses up turn: No
     * 
     * Allows a client connection to take control of an egg, identified by the
     * egg ID parameter. Returns the DinosaurState of the newly controlled
     * dinosaur if successful, throws an exception otherwise.
     * 
     * @param eggID
     */
    public DinosaurState hatch(long eggID) throws BadEggException, YouAreDeadException, GameOverException, TException;

    /**
     * Lay an egg
     * 
     * Costs calories: Yes
     * Uses up turn: Yes
     * 
     * Lays an egg in the specified direction, in addition to giving the new
     * egg some calories to help it survive. This function costs calories to use
     * and your dinosaur is responsible for ensuring it has enough to call this
     * function without starving to death. The cost of this function is equal to
     * the eggCost value (found in any DinosaurState struct returned) plus the
     * calories given to the egg. The newly hatched dinosaur will not gain all
     * of these calories, up to 20% of them will be lost in the transfer.
     * 
     * This function returns an EggResults on success that contains useful
     * information, such as the current state of the egg laying dinosaur, the
     * egg ID of the newly laid egg, among other info. Another Dinosaur Island
     * client can then connect and start playing after calling the hatch func
     * with the egg ID. This function throws an exception otherwise.
     * 
     * @param direction
     * @param calories_given
     */
    public EggResults egg(int direction, int calories_given) throws YouAreDeadException, GameOverException, TException;

    /**
     * Look (in a direction)
     * 
     * Costs calories: Yes
     * Uses up turn: Yes
     * 
     * If successful, the dinosaur will use up a number of calories (found in any
     * DinosaurState struct returned) and return an list of Sighting structs
     * representing things the dinosaur saw in that direction. Sight is treated
     * as a cone radiating out from the dinosaur in question.
     * 
     * How far a dinosaur can see is dependent on how big the actual dinosaur
     * is, and the sizes of the objects in the cone.
     * 
     * Two examples of cone shapes are given below:
     * 
     *              +                  +
     *             ++                  ++
     *            +++                  +++
     *           D+++                  ++++
     *            +++                  +++++
     *             ++                  ++++++
     *              +                  D++++++
     * 
     * @param direction
     */
    public LookResults look(int direction) throws YouAreDeadException, GameOverException, TException;

    /**
     * Grow
     * 
     * Costs calories: Yes
     * Uses up turn: Yes
     * 
     * If successful, the dinosaur will increments its size by one. All dinosaurs
     * start with a size of one. Size is used in determining how far a dinosaur
     * can see (or how easily your dinosaur can be seen), as well as how likely
     * a dinosaur is in winning a fight with another dinosaur. Lastly, if your
     * dinosaur is eaten, it will be worth more calories the bigger it is.
     * 
     * This function returns a GrowResults struct upon success and throws an
     * exception otherwise.
     */
    public GrowResults grow() throws YouAreDeadException, GameOverException, TException;

    /**
     * Move
     * 
     * Costs calories: Yes
     * Uses up turn: Yes
     * 
     * Moves the dinosaur in the direction specified; if an entity exists in the
     * target square, the dinosaur will fight with that entity.
     * 
     * Plants always lose battles, no matter what moves into their square. If the
     * attacker is an herbivore, it will gain calories based upon the plant's
     * size. Carnivores merely destroy the plant with no calories gained.
     * 
     * If one dinosaur moves into another, they will fight. Carnivores gain a
     * significant boost to their odds of victory when fighting herbivores. If
     * a carnivore wins over an herbivore, it will gain calories based upon the
     * size of the herbivore, and how many calories the herbivore had at time of
     * death.
     * 
     * If your dinosaur attempts to move into impassable terrain, the
     * MoveResults struct will contain a success boolean of false, indicating
     * the dinosaur did not actually change positions.
     * 
     * @param direction
     */
    public MoveResults move(int direction) throws YouAreDeadException, GameOverException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public RegisterClientResults registerClient(String email, String highScoreName, int type) throws AlreadyRegisteredException, TException
    {
      send_registerClient(email, highScoreName, type);
      return recv_registerClient();
    }

    public void send_registerClient(String email, String highScoreName, int type) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("registerClient", TMessageType.CALL, seqid_));
      registerClient_args args = new registerClient_args();
      args.email = email;
      args.highScoreName = highScoreName;
      args.type = type;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public RegisterClientResults recv_registerClient() throws AlreadyRegisteredException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      registerClient_result result = new registerClient_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.alreadyRegistered != null) {
        throw result.alreadyRegistered;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "registerClient failed: unknown result");
    }

    public DinosaurState hatch(long eggID) throws BadEggException, YouAreDeadException, GameOverException, TException
    {
      send_hatch(eggID);
      return recv_hatch();
    }

    public void send_hatch(long eggID) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("hatch", TMessageType.CALL, seqid_));
      hatch_args args = new hatch_args();
      args.eggID = eggID;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public DinosaurState recv_hatch() throws BadEggException, YouAreDeadException, GameOverException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      hatch_result result = new hatch_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.badEgg != null) {
        throw result.badEgg;
      }
      if (result.youAreDead != null) {
        throw result.youAreDead;
      }
      if (result.gameOver != null) {
        throw result.gameOver;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "hatch failed: unknown result");
    }

    public EggResults egg(int direction, int calories_given) throws YouAreDeadException, GameOverException, TException
    {
      send_egg(direction, calories_given);
      return recv_egg();
    }

    public void send_egg(int direction, int calories_given) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("egg", TMessageType.CALL, seqid_));
      egg_args args = new egg_args();
      args.direction = direction;
      args.calories_given = calories_given;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public EggResults recv_egg() throws YouAreDeadException, GameOverException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      egg_result result = new egg_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.youAreDead != null) {
        throw result.youAreDead;
      }
      if (result.gameOver != null) {
        throw result.gameOver;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "egg failed: unknown result");
    }

    public LookResults look(int direction) throws YouAreDeadException, GameOverException, TException
    {
      send_look(direction);
      return recv_look();
    }

    public void send_look(int direction) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("look", TMessageType.CALL, seqid_));
      look_args args = new look_args();
      args.direction = direction;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public LookResults recv_look() throws YouAreDeadException, GameOverException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      look_result result = new look_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.youAreDead != null) {
        throw result.youAreDead;
      }
      if (result.gameOver != null) {
        throw result.gameOver;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "look failed: unknown result");
    }

    public GrowResults grow() throws YouAreDeadException, GameOverException, TException
    {
      send_grow();
      return recv_grow();
    }

    public void send_grow() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("grow", TMessageType.CALL, seqid_));
      grow_args args = new grow_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public GrowResults recv_grow() throws YouAreDeadException, GameOverException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      grow_result result = new grow_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.youAreDead != null) {
        throw result.youAreDead;
      }
      if (result.gameOver != null) {
        throw result.gameOver;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "grow failed: unknown result");
    }

    public MoveResults move(int direction) throws YouAreDeadException, GameOverException, TException
    {
      send_move(direction);
      return recv_move();
    }

    public void send_move(int direction) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("move", TMessageType.CALL, seqid_));
      move_args args = new move_args();
      args.direction = direction;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public MoveResults recv_move() throws YouAreDeadException, GameOverException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      move_result result = new move_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.youAreDead != null) {
        throw result.youAreDead;
      }
      if (result.gameOver != null) {
        throw result.gameOver;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "move failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("registerClient", new registerClient());
      processMap_.put("hatch", new hatch());
      processMap_.put("egg", new egg());
      processMap_.put("look", new look());
      processMap_.put("grow", new grow());
      processMap_.put("move", new move());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class registerClient implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        registerClient_args args = new registerClient_args();
        args.read(iprot);
        iprot.readMessageEnd();
        registerClient_result result = new registerClient_result();
        try {
          result.success = iface_.registerClient(args.email, args.highScoreName, args.type);
        } catch (AlreadyRegisteredException alreadyRegistered) {
          result.alreadyRegistered = alreadyRegistered;
        }
        oprot.writeMessageBegin(new TMessage("registerClient", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class hatch implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        hatch_args args = new hatch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        hatch_result result = new hatch_result();
        try {
          result.success = iface_.hatch(args.eggID);
        } catch (BadEggException badEgg) {
          result.badEgg = badEgg;
        } catch (YouAreDeadException youAreDead) {
          result.youAreDead = youAreDead;
        } catch (GameOverException gameOver) {
          result.gameOver = gameOver;
        }
        oprot.writeMessageBegin(new TMessage("hatch", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class egg implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        egg_args args = new egg_args();
        args.read(iprot);
        iprot.readMessageEnd();
        egg_result result = new egg_result();
        try {
          result.success = iface_.egg(args.direction, args.calories_given);
        } catch (YouAreDeadException youAreDead) {
          result.youAreDead = youAreDead;
        } catch (GameOverException gameOver) {
          result.gameOver = gameOver;
        }
        oprot.writeMessageBegin(new TMessage("egg", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class look implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        look_args args = new look_args();
        args.read(iprot);
        iprot.readMessageEnd();
        look_result result = new look_result();
        try {
          result.success = iface_.look(args.direction);
        } catch (YouAreDeadException youAreDead) {
          result.youAreDead = youAreDead;
        } catch (GameOverException gameOver) {
          result.gameOver = gameOver;
        }
        oprot.writeMessageBegin(new TMessage("look", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class grow implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        grow_args args = new grow_args();
        args.read(iprot);
        iprot.readMessageEnd();
        grow_result result = new grow_result();
        try {
          result.success = iface_.grow();
        } catch (YouAreDeadException youAreDead) {
          result.youAreDead = youAreDead;
        } catch (GameOverException gameOver) {
          result.gameOver = gameOver;
        }
        oprot.writeMessageBegin(new TMessage("grow", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class move implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        move_args args = new move_args();
        args.read(iprot);
        iprot.readMessageEnd();
        move_result result = new move_result();
        try {
          result.success = iface_.move(args.direction);
        } catch (YouAreDeadException youAreDead) {
          result.youAreDead = youAreDead;
        } catch (GameOverException gameOver) {
          result.gameOver = gameOver;
        }
        oprot.writeMessageBegin(new TMessage("move", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class registerClient_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("registerClient_args");
    private static final TField EMAIL_FIELD_DESC = new TField("email", TType.STRING, (short)-1);
    private static final TField HIGH_SCORE_NAME_FIELD_DESC = new TField("highScoreName", TType.STRING, (short)-2);
    private static final TField TYPE_FIELD_DESC = new TField("type", TType.I32, (short)-3);

    public String email;
    public static final int EMAIL = -1;
    public String highScoreName;
    public static final int HIGHSCORENAME = -2;
    public int type;
    public static final int TYPE = -3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean type = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EMAIL, new FieldMetaData("email", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(HIGHSCORENAME, new FieldMetaData("highScoreName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(TYPE, new FieldMetaData("type", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(registerClient_args.class, metaDataMap);
    }

    public registerClient_args() {
    }

    public registerClient_args(
      String email,
      String highScoreName,
      int type)
    {
      this();
      this.email = email;
      this.highScoreName = highScoreName;
      this.type = type;
      this.__isset.type = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public registerClient_args(registerClient_args other) {
      if (other.isSetEmail()) {
        this.email = other.email;
      }
      if (other.isSetHighScoreName()) {
        this.highScoreName = other.highScoreName;
      }
      __isset.type = other.__isset.type;
      this.type = other.type;
    }

    @Override
    public registerClient_args clone() {
      return new registerClient_args(this);
    }

    public String getEmail() {
      return this.email;
    }

    public void setEmail(String email) {
      this.email = email;
    }

    public void unsetEmail() {
      this.email = null;
    }

    // Returns true if field email is set (has been asigned a value) and false otherwise
    public boolean isSetEmail() {
      return this.email != null;
    }

    public void setEmailIsSet(boolean value) {
      if (!value) {
        this.email = null;
      }
    }

    public String getHighScoreName() {
      return this.highScoreName;
    }

    public void setHighScoreName(String highScoreName) {
      this.highScoreName = highScoreName;
    }

    public void unsetHighScoreName() {
      this.highScoreName = null;
    }

    // Returns true if field highScoreName is set (has been asigned a value) and false otherwise
    public boolean isSetHighScoreName() {
      return this.highScoreName != null;
    }

    public void setHighScoreNameIsSet(boolean value) {
      if (!value) {
        this.highScoreName = null;
      }
    }

    public int getType() {
      return this.type;
    }

    public void setType(int type) {
      this.type = type;
      this.__isset.type = true;
    }

    public void unsetType() {
      this.__isset.type = false;
    }

    // Returns true if field type is set (has been asigned a value) and false otherwise
    public boolean isSetType() {
      return this.__isset.type;
    }

    public void setTypeIsSet(boolean value) {
      this.__isset.type = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EMAIL:
        if (value == null) {
          unsetEmail();
        } else {
          setEmail((String)value);
        }
        break;

      case HIGHSCORENAME:
        if (value == null) {
          unsetHighScoreName();
        } else {
          setHighScoreName((String)value);
        }
        break;

      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          setType((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EMAIL:
        return getEmail();

      case HIGHSCORENAME:
        return getHighScoreName();

      case TYPE:
        return getType();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EMAIL:
        return isSetEmail();
      case HIGHSCORENAME:
        return isSetHighScoreName();
      case TYPE:
        return isSetType();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof registerClient_args)
        return this.equals((registerClient_args)that);
      return false;
    }

    public boolean equals(registerClient_args that) {
      if (that == null)
        return false;

      boolean this_present_email = true && this.isSetEmail();
      boolean that_present_email = true && that.isSetEmail();
      if (this_present_email || that_present_email) {
        if (!(this_present_email && that_present_email))
          return false;
        if (!this.email.equals(that.email))
          return false;
      }

      boolean this_present_highScoreName = true && this.isSetHighScoreName();
      boolean that_present_highScoreName = true && that.isSetHighScoreName();
      if (this_present_highScoreName || that_present_highScoreName) {
        if (!(this_present_highScoreName && that_present_highScoreName))
          return false;
        if (!this.highScoreName.equals(that.highScoreName))
          return false;
      }

      boolean this_present_type = true;
      boolean that_present_type = true;
      if (this_present_type || that_present_type) {
        if (!(this_present_type && that_present_type))
          return false;
        if (this.type != that.type)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EMAIL:
            if (field.type == TType.STRING) {
              this.email = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case HIGHSCORENAME:
            if (field.type == TType.STRING) {
              this.highScoreName = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TYPE:
            if (field.type == TType.I32) {
              this.type = iprot.readI32();
              this.__isset.type = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(TYPE_FIELD_DESC);
      oprot.writeI32(this.type);
      oprot.writeFieldEnd();
      if (this.highScoreName != null) {
        oprot.writeFieldBegin(HIGH_SCORE_NAME_FIELD_DESC);
        oprot.writeString(this.highScoreName);
        oprot.writeFieldEnd();
      }
      if (this.email != null) {
        oprot.writeFieldBegin(EMAIL_FIELD_DESC);
        oprot.writeString(this.email);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("registerClient_args(");
      boolean first = true;

      sb.append("email:");
      if (this.email == null) {
        sb.append("null");
      } else {
        sb.append(this.email);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("highScoreName:");
      if (this.highScoreName == null) {
        sb.append("null");
      } else {
        sb.append(this.highScoreName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("type:");
      String type_name = EntityType.VALUES_TO_NAMES.get(this.type);
      if (type_name != null) {
        sb.append(type_name);
        sb.append(" (");
      }
      sb.append(this.type);
      if (type_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
      if (isSetType() && !EntityType.VALID_VALUES.contains(type)){
        throw new TProtocolException("The field 'type' has been assigned the invalid value " + type);
      }
    }

  }

  public static class registerClient_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("registerClient_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField ALREADY_REGISTERED_FIELD_DESC = new TField("alreadyRegistered", TType.STRUCT, (short)-1);

    public RegisterClientResults success;
    public static final int SUCCESS = 0;
    public AlreadyRegisteredException alreadyRegistered;
    public static final int ALREADYREGISTERED = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RegisterClientResults.class)));
      put(ALREADYREGISTERED, new FieldMetaData("alreadyRegistered", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(registerClient_result.class, metaDataMap);
    }

    public registerClient_result() {
    }

    public registerClient_result(
      RegisterClientResults success,
      AlreadyRegisteredException alreadyRegistered)
    {
      this();
      this.success = success;
      this.alreadyRegistered = alreadyRegistered;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public registerClient_result(registerClient_result other) {
      if (other.isSetSuccess()) {
        this.success = new RegisterClientResults(other.success);
      }
      if (other.isSetAlreadyRegistered()) {
        this.alreadyRegistered = new AlreadyRegisteredException(other.alreadyRegistered);
      }
    }

    @Override
    public registerClient_result clone() {
      return new registerClient_result(this);
    }

    public RegisterClientResults getSuccess() {
      return this.success;
    }

    public void setSuccess(RegisterClientResults success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public AlreadyRegisteredException getAlreadyRegistered() {
      return this.alreadyRegistered;
    }

    public void setAlreadyRegistered(AlreadyRegisteredException alreadyRegistered) {
      this.alreadyRegistered = alreadyRegistered;
    }

    public void unsetAlreadyRegistered() {
      this.alreadyRegistered = null;
    }

    // Returns true if field alreadyRegistered is set (has been asigned a value) and false otherwise
    public boolean isSetAlreadyRegistered() {
      return this.alreadyRegistered != null;
    }

    public void setAlreadyRegisteredIsSet(boolean value) {
      if (!value) {
        this.alreadyRegistered = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RegisterClientResults)value);
        }
        break;

      case ALREADYREGISTERED:
        if (value == null) {
          unsetAlreadyRegistered();
        } else {
          setAlreadyRegistered((AlreadyRegisteredException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ALREADYREGISTERED:
        return getAlreadyRegistered();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ALREADYREGISTERED:
        return isSetAlreadyRegistered();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof registerClient_result)
        return this.equals((registerClient_result)that);
      return false;
    }

    public boolean equals(registerClient_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_alreadyRegistered = true && this.isSetAlreadyRegistered();
      boolean that_present_alreadyRegistered = true && that.isSetAlreadyRegistered();
      if (this_present_alreadyRegistered || that_present_alreadyRegistered) {
        if (!(this_present_alreadyRegistered && that_present_alreadyRegistered))
          return false;
        if (!this.alreadyRegistered.equals(that.alreadyRegistered))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new RegisterClientResults();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ALREADYREGISTERED:
            if (field.type == TType.STRUCT) {
              this.alreadyRegistered = new AlreadyRegisteredException();
              this.alreadyRegistered.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetAlreadyRegistered()) {
        oprot.writeFieldBegin(ALREADY_REGISTERED_FIELD_DESC);
        this.alreadyRegistered.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("registerClient_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("alreadyRegistered:");
      if (this.alreadyRegistered == null) {
        sb.append("null");
      } else {
        sb.append(this.alreadyRegistered);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class hatch_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("hatch_args");
    private static final TField EGG_ID_FIELD_DESC = new TField("eggID", TType.I64, (short)-1);

    public long eggID;
    public static final int EGGID = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean eggID = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EGGID, new FieldMetaData("eggID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(hatch_args.class, metaDataMap);
    }

    public hatch_args() {
    }

    public hatch_args(
      long eggID)
    {
      this();
      this.eggID = eggID;
      this.__isset.eggID = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public hatch_args(hatch_args other) {
      __isset.eggID = other.__isset.eggID;
      this.eggID = other.eggID;
    }

    @Override
    public hatch_args clone() {
      return new hatch_args(this);
    }

    public long getEggID() {
      return this.eggID;
    }

    public void setEggID(long eggID) {
      this.eggID = eggID;
      this.__isset.eggID = true;
    }

    public void unsetEggID() {
      this.__isset.eggID = false;
    }

    // Returns true if field eggID is set (has been asigned a value) and false otherwise
    public boolean isSetEggID() {
      return this.__isset.eggID;
    }

    public void setEggIDIsSet(boolean value) {
      this.__isset.eggID = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EGGID:
        if (value == null) {
          unsetEggID();
        } else {
          setEggID((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EGGID:
        return new Long(getEggID());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EGGID:
        return isSetEggID();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof hatch_args)
        return this.equals((hatch_args)that);
      return false;
    }

    public boolean equals(hatch_args that) {
      if (that == null)
        return false;

      boolean this_present_eggID = true;
      boolean that_present_eggID = true;
      if (this_present_eggID || that_present_eggID) {
        if (!(this_present_eggID && that_present_eggID))
          return false;
        if (this.eggID != that.eggID)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EGGID:
            if (field.type == TType.I64) {
              this.eggID = iprot.readI64();
              this.__isset.eggID = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(EGG_ID_FIELD_DESC);
      oprot.writeI64(this.eggID);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("hatch_args(");
      boolean first = true;

      sb.append("eggID:");
      sb.append(this.eggID);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class hatch_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("hatch_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField BAD_EGG_FIELD_DESC = new TField("badEgg", TType.STRUCT, (short)-1);
    private static final TField YOU_ARE_DEAD_FIELD_DESC = new TField("youAreDead", TType.STRUCT, (short)-2);
    private static final TField GAME_OVER_FIELD_DESC = new TField("gameOver", TType.STRUCT, (short)-3);

    public DinosaurState success;
    public static final int SUCCESS = 0;
    public BadEggException badEgg;
    public static final int BADEGG = -1;
    public YouAreDeadException youAreDead;
    public static final int YOUAREDEAD = -2;
    public GameOverException gameOver;
    public static final int GAMEOVER = -3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DinosaurState.class)));
      put(BADEGG, new FieldMetaData("badEgg", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(YOUAREDEAD, new FieldMetaData("youAreDead", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(GAMEOVER, new FieldMetaData("gameOver", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(hatch_result.class, metaDataMap);
    }

    public hatch_result() {
    }

    public hatch_result(
      DinosaurState success,
      BadEggException badEgg,
      YouAreDeadException youAreDead,
      GameOverException gameOver)
    {
      this();
      this.success = success;
      this.badEgg = badEgg;
      this.youAreDead = youAreDead;
      this.gameOver = gameOver;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public hatch_result(hatch_result other) {
      if (other.isSetSuccess()) {
        this.success = new DinosaurState(other.success);
      }
      if (other.isSetBadEgg()) {
        this.badEgg = new BadEggException(other.badEgg);
      }
      if (other.isSetYouAreDead()) {
        this.youAreDead = new YouAreDeadException(other.youAreDead);
      }
      if (other.isSetGameOver()) {
        this.gameOver = new GameOverException(other.gameOver);
      }
    }

    @Override
    public hatch_result clone() {
      return new hatch_result(this);
    }

    public DinosaurState getSuccess() {
      return this.success;
    }

    public void setSuccess(DinosaurState success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public BadEggException getBadEgg() {
      return this.badEgg;
    }

    public void setBadEgg(BadEggException badEgg) {
      this.badEgg = badEgg;
    }

    public void unsetBadEgg() {
      this.badEgg = null;
    }

    // Returns true if field badEgg is set (has been asigned a value) and false otherwise
    public boolean isSetBadEgg() {
      return this.badEgg != null;
    }

    public void setBadEggIsSet(boolean value) {
      if (!value) {
        this.badEgg = null;
      }
    }

    public YouAreDeadException getYouAreDead() {
      return this.youAreDead;
    }

    public void setYouAreDead(YouAreDeadException youAreDead) {
      this.youAreDead = youAreDead;
    }

    public void unsetYouAreDead() {
      this.youAreDead = null;
    }

    // Returns true if field youAreDead is set (has been asigned a value) and false otherwise
    public boolean isSetYouAreDead() {
      return this.youAreDead != null;
    }

    public void setYouAreDeadIsSet(boolean value) {
      if (!value) {
        this.youAreDead = null;
      }
    }

    public GameOverException getGameOver() {
      return this.gameOver;
    }

    public void setGameOver(GameOverException gameOver) {
      this.gameOver = gameOver;
    }

    public void unsetGameOver() {
      this.gameOver = null;
    }

    // Returns true if field gameOver is set (has been asigned a value) and false otherwise
    public boolean isSetGameOver() {
      return this.gameOver != null;
    }

    public void setGameOverIsSet(boolean value) {
      if (!value) {
        this.gameOver = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((DinosaurState)value);
        }
        break;

      case BADEGG:
        if (value == null) {
          unsetBadEgg();
        } else {
          setBadEgg((BadEggException)value);
        }
        break;

      case YOUAREDEAD:
        if (value == null) {
          unsetYouAreDead();
        } else {
          setYouAreDead((YouAreDeadException)value);
        }
        break;

      case GAMEOVER:
        if (value == null) {
          unsetGameOver();
        } else {
          setGameOver((GameOverException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case BADEGG:
        return getBadEgg();

      case YOUAREDEAD:
        return getYouAreDead();

      case GAMEOVER:
        return getGameOver();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case BADEGG:
        return isSetBadEgg();
      case YOUAREDEAD:
        return isSetYouAreDead();
      case GAMEOVER:
        return isSetGameOver();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof hatch_result)
        return this.equals((hatch_result)that);
      return false;
    }

    public boolean equals(hatch_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_badEgg = true && this.isSetBadEgg();
      boolean that_present_badEgg = true && that.isSetBadEgg();
      if (this_present_badEgg || that_present_badEgg) {
        if (!(this_present_badEgg && that_present_badEgg))
          return false;
        if (!this.badEgg.equals(that.badEgg))
          return false;
      }

      boolean this_present_youAreDead = true && this.isSetYouAreDead();
      boolean that_present_youAreDead = true && that.isSetYouAreDead();
      if (this_present_youAreDead || that_present_youAreDead) {
        if (!(this_present_youAreDead && that_present_youAreDead))
          return false;
        if (!this.youAreDead.equals(that.youAreDead))
          return false;
      }

      boolean this_present_gameOver = true && this.isSetGameOver();
      boolean that_present_gameOver = true && that.isSetGameOver();
      if (this_present_gameOver || that_present_gameOver) {
        if (!(this_present_gameOver && that_present_gameOver))
          return false;
        if (!this.gameOver.equals(that.gameOver))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new DinosaurState();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BADEGG:
            if (field.type == TType.STRUCT) {
              this.badEgg = new BadEggException();
              this.badEgg.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case YOUAREDEAD:
            if (field.type == TType.STRUCT) {
              this.youAreDead = new YouAreDeadException();
              this.youAreDead.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GAMEOVER:
            if (field.type == TType.STRUCT) {
              this.gameOver = new GameOverException();
              this.gameOver.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetGameOver()) {
        oprot.writeFieldBegin(GAME_OVER_FIELD_DESC);
        this.gameOver.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetYouAreDead()) {
        oprot.writeFieldBegin(YOU_ARE_DEAD_FIELD_DESC);
        this.youAreDead.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetBadEgg()) {
        oprot.writeFieldBegin(BAD_EGG_FIELD_DESC);
        this.badEgg.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("hatch_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("badEgg:");
      if (this.badEgg == null) {
        sb.append("null");
      } else {
        sb.append(this.badEgg);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("youAreDead:");
      if (this.youAreDead == null) {
        sb.append("null");
      } else {
        sb.append(this.youAreDead);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("gameOver:");
      if (this.gameOver == null) {
        sb.append("null");
      } else {
        sb.append(this.gameOver);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class egg_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("egg_args");
    private static final TField DIRECTION_FIELD_DESC = new TField("direction", TType.I32, (short)-1);
    private static final TField CALORIES_GIVEN_FIELD_DESC = new TField("calories_given", TType.I32, (short)-2);

    public int direction;
    public static final int DIRECTION = -1;
    public int calories_given;
    public static final int CALORIES_GIVEN = -2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean direction = false;
      public boolean calories_given = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(DIRECTION, new FieldMetaData("direction", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(CALORIES_GIVEN, new FieldMetaData("calories_given", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(egg_args.class, metaDataMap);
    }

    public egg_args() {
    }

    public egg_args(
      int direction,
      int calories_given)
    {
      this();
      this.direction = direction;
      this.__isset.direction = true;
      this.calories_given = calories_given;
      this.__isset.calories_given = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public egg_args(egg_args other) {
      __isset.direction = other.__isset.direction;
      this.direction = other.direction;
      __isset.calories_given = other.__isset.calories_given;
      this.calories_given = other.calories_given;
    }

    @Override
    public egg_args clone() {
      return new egg_args(this);
    }

    public int getDirection() {
      return this.direction;
    }

    public void setDirection(int direction) {
      this.direction = direction;
      this.__isset.direction = true;
    }

    public void unsetDirection() {
      this.__isset.direction = false;
    }

    // Returns true if field direction is set (has been asigned a value) and false otherwise
    public boolean isSetDirection() {
      return this.__isset.direction;
    }

    public void setDirectionIsSet(boolean value) {
      this.__isset.direction = value;
    }

    public int getCalories_given() {
      return this.calories_given;
    }

    public void setCalories_given(int calories_given) {
      this.calories_given = calories_given;
      this.__isset.calories_given = true;
    }

    public void unsetCalories_given() {
      this.__isset.calories_given = false;
    }

    // Returns true if field calories_given is set (has been asigned a value) and false otherwise
    public boolean isSetCalories_given() {
      return this.__isset.calories_given;
    }

    public void setCalories_givenIsSet(boolean value) {
      this.__isset.calories_given = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case DIRECTION:
        if (value == null) {
          unsetDirection();
        } else {
          setDirection((Integer)value);
        }
        break;

      case CALORIES_GIVEN:
        if (value == null) {
          unsetCalories_given();
        } else {
          setCalories_given((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case DIRECTION:
        return getDirection();

      case CALORIES_GIVEN:
        return new Integer(getCalories_given());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case DIRECTION:
        return isSetDirection();
      case CALORIES_GIVEN:
        return isSetCalories_given();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof egg_args)
        return this.equals((egg_args)that);
      return false;
    }

    public boolean equals(egg_args that) {
      if (that == null)
        return false;

      boolean this_present_direction = true;
      boolean that_present_direction = true;
      if (this_present_direction || that_present_direction) {
        if (!(this_present_direction && that_present_direction))
          return false;
        if (this.direction != that.direction)
          return false;
      }

      boolean this_present_calories_given = true;
      boolean that_present_calories_given = true;
      if (this_present_calories_given || that_present_calories_given) {
        if (!(this_present_calories_given && that_present_calories_given))
          return false;
        if (this.calories_given != that.calories_given)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case DIRECTION:
            if (field.type == TType.I32) {
              this.direction = iprot.readI32();
              this.__isset.direction = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CALORIES_GIVEN:
            if (field.type == TType.I32) {
              this.calories_given = iprot.readI32();
              this.__isset.calories_given = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(CALORIES_GIVEN_FIELD_DESC);
      oprot.writeI32(this.calories_given);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(DIRECTION_FIELD_DESC);
      oprot.writeI32(this.direction);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("egg_args(");
      boolean first = true;

      sb.append("direction:");
      String direction_name = Direction.VALUES_TO_NAMES.get(this.direction);
      if (direction_name != null) {
        sb.append(direction_name);
        sb.append(" (");
      }
      sb.append(this.direction);
      if (direction_name != null) {
        sb.append(")");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("calories_given:");
      sb.append(this.calories_given);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
      if (isSetDirection() && !Direction.VALID_VALUES.contains(direction)){
        throw new TProtocolException("The field 'direction' has been assigned the invalid value " + direction);
      }
    }

  }

  public static class egg_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("egg_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField YOU_ARE_DEAD_FIELD_DESC = new TField("youAreDead", TType.STRUCT, (short)-1);
    private static final TField GAME_OVER_FIELD_DESC = new TField("gameOver", TType.STRUCT, (short)-2);

    public EggResults success;
    public static final int SUCCESS = 0;
    public YouAreDeadException youAreDead;
    public static final int YOUAREDEAD = -1;
    public GameOverException gameOver;
    public static final int GAMEOVER = -2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, EggResults.class)));
      put(YOUAREDEAD, new FieldMetaData("youAreDead", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(GAMEOVER, new FieldMetaData("gameOver", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(egg_result.class, metaDataMap);
    }

    public egg_result() {
    }

    public egg_result(
      EggResults success,
      YouAreDeadException youAreDead,
      GameOverException gameOver)
    {
      this();
      this.success = success;
      this.youAreDead = youAreDead;
      this.gameOver = gameOver;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public egg_result(egg_result other) {
      if (other.isSetSuccess()) {
        this.success = new EggResults(other.success);
      }
      if (other.isSetYouAreDead()) {
        this.youAreDead = new YouAreDeadException(other.youAreDead);
      }
      if (other.isSetGameOver()) {
        this.gameOver = new GameOverException(other.gameOver);
      }
    }

    @Override
    public egg_result clone() {
      return new egg_result(this);
    }

    public EggResults getSuccess() {
      return this.success;
    }

    public void setSuccess(EggResults success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public YouAreDeadException getYouAreDead() {
      return this.youAreDead;
    }

    public void setYouAreDead(YouAreDeadException youAreDead) {
      this.youAreDead = youAreDead;
    }

    public void unsetYouAreDead() {
      this.youAreDead = null;
    }

    // Returns true if field youAreDead is set (has been asigned a value) and false otherwise
    public boolean isSetYouAreDead() {
      return this.youAreDead != null;
    }

    public void setYouAreDeadIsSet(boolean value) {
      if (!value) {
        this.youAreDead = null;
      }
    }

    public GameOverException getGameOver() {
      return this.gameOver;
    }

    public void setGameOver(GameOverException gameOver) {
      this.gameOver = gameOver;
    }

    public void unsetGameOver() {
      this.gameOver = null;
    }

    // Returns true if field gameOver is set (has been asigned a value) and false otherwise
    public boolean isSetGameOver() {
      return this.gameOver != null;
    }

    public void setGameOverIsSet(boolean value) {
      if (!value) {
        this.gameOver = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((EggResults)value);
        }
        break;

      case YOUAREDEAD:
        if (value == null) {
          unsetYouAreDead();
        } else {
          setYouAreDead((YouAreDeadException)value);
        }
        break;

      case GAMEOVER:
        if (value == null) {
          unsetGameOver();
        } else {
          setGameOver((GameOverException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case YOUAREDEAD:
        return getYouAreDead();

      case GAMEOVER:
        return getGameOver();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case YOUAREDEAD:
        return isSetYouAreDead();
      case GAMEOVER:
        return isSetGameOver();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof egg_result)
        return this.equals((egg_result)that);
      return false;
    }

    public boolean equals(egg_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_youAreDead = true && this.isSetYouAreDead();
      boolean that_present_youAreDead = true && that.isSetYouAreDead();
      if (this_present_youAreDead || that_present_youAreDead) {
        if (!(this_present_youAreDead && that_present_youAreDead))
          return false;
        if (!this.youAreDead.equals(that.youAreDead))
          return false;
      }

      boolean this_present_gameOver = true && this.isSetGameOver();
      boolean that_present_gameOver = true && that.isSetGameOver();
      if (this_present_gameOver || that_present_gameOver) {
        if (!(this_present_gameOver && that_present_gameOver))
          return false;
        if (!this.gameOver.equals(that.gameOver))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new EggResults();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case YOUAREDEAD:
            if (field.type == TType.STRUCT) {
              this.youAreDead = new YouAreDeadException();
              this.youAreDead.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GAMEOVER:
            if (field.type == TType.STRUCT) {
              this.gameOver = new GameOverException();
              this.gameOver.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetGameOver()) {
        oprot.writeFieldBegin(GAME_OVER_FIELD_DESC);
        this.gameOver.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetYouAreDead()) {
        oprot.writeFieldBegin(YOU_ARE_DEAD_FIELD_DESC);
        this.youAreDead.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("egg_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("youAreDead:");
      if (this.youAreDead == null) {
        sb.append("null");
      } else {
        sb.append(this.youAreDead);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("gameOver:");
      if (this.gameOver == null) {
        sb.append("null");
      } else {
        sb.append(this.gameOver);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class look_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("look_args");
    private static final TField DIRECTION_FIELD_DESC = new TField("direction", TType.I32, (short)-1);

    public int direction;
    public static final int DIRECTION = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean direction = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(DIRECTION, new FieldMetaData("direction", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(look_args.class, metaDataMap);
    }

    public look_args() {
    }

    public look_args(
      int direction)
    {
      this();
      this.direction = direction;
      this.__isset.direction = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public look_args(look_args other) {
      __isset.direction = other.__isset.direction;
      this.direction = other.direction;
    }

    @Override
    public look_args clone() {
      return new look_args(this);
    }

    public int getDirection() {
      return this.direction;
    }

    public void setDirection(int direction) {
      this.direction = direction;
      this.__isset.direction = true;
    }

    public void unsetDirection() {
      this.__isset.direction = false;
    }

    // Returns true if field direction is set (has been asigned a value) and false otherwise
    public boolean isSetDirection() {
      return this.__isset.direction;
    }

    public void setDirectionIsSet(boolean value) {
      this.__isset.direction = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case DIRECTION:
        if (value == null) {
          unsetDirection();
        } else {
          setDirection((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case DIRECTION:
        return getDirection();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case DIRECTION:
        return isSetDirection();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof look_args)
        return this.equals((look_args)that);
      return false;
    }

    public boolean equals(look_args that) {
      if (that == null)
        return false;

      boolean this_present_direction = true;
      boolean that_present_direction = true;
      if (this_present_direction || that_present_direction) {
        if (!(this_present_direction && that_present_direction))
          return false;
        if (this.direction != that.direction)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case DIRECTION:
            if (field.type == TType.I32) {
              this.direction = iprot.readI32();
              this.__isset.direction = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(DIRECTION_FIELD_DESC);
      oprot.writeI32(this.direction);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("look_args(");
      boolean first = true;

      sb.append("direction:");
      String direction_name = Direction.VALUES_TO_NAMES.get(this.direction);
      if (direction_name != null) {
        sb.append(direction_name);
        sb.append(" (");
      }
      sb.append(this.direction);
      if (direction_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
      if (isSetDirection() && !Direction.VALID_VALUES.contains(direction)){
        throw new TProtocolException("The field 'direction' has been assigned the invalid value " + direction);
      }
    }

  }

  public static class look_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("look_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField YOU_ARE_DEAD_FIELD_DESC = new TField("youAreDead", TType.STRUCT, (short)-1);
    private static final TField GAME_OVER_FIELD_DESC = new TField("gameOver", TType.STRUCT, (short)-2);

    public LookResults success;
    public static final int SUCCESS = 0;
    public YouAreDeadException youAreDead;
    public static final int YOUAREDEAD = -1;
    public GameOverException gameOver;
    public static final int GAMEOVER = -2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, LookResults.class)));
      put(YOUAREDEAD, new FieldMetaData("youAreDead", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(GAMEOVER, new FieldMetaData("gameOver", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(look_result.class, metaDataMap);
    }

    public look_result() {
    }

    public look_result(
      LookResults success,
      YouAreDeadException youAreDead,
      GameOverException gameOver)
    {
      this();
      this.success = success;
      this.youAreDead = youAreDead;
      this.gameOver = gameOver;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public look_result(look_result other) {
      if (other.isSetSuccess()) {
        this.success = new LookResults(other.success);
      }
      if (other.isSetYouAreDead()) {
        this.youAreDead = new YouAreDeadException(other.youAreDead);
      }
      if (other.isSetGameOver()) {
        this.gameOver = new GameOverException(other.gameOver);
      }
    }

    @Override
    public look_result clone() {
      return new look_result(this);
    }

    public LookResults getSuccess() {
      return this.success;
    }

    public void setSuccess(LookResults success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public YouAreDeadException getYouAreDead() {
      return this.youAreDead;
    }

    public void setYouAreDead(YouAreDeadException youAreDead) {
      this.youAreDead = youAreDead;
    }

    public void unsetYouAreDead() {
      this.youAreDead = null;
    }

    // Returns true if field youAreDead is set (has been asigned a value) and false otherwise
    public boolean isSetYouAreDead() {
      return this.youAreDead != null;
    }

    public void setYouAreDeadIsSet(boolean value) {
      if (!value) {
        this.youAreDead = null;
      }
    }

    public GameOverException getGameOver() {
      return this.gameOver;
    }

    public void setGameOver(GameOverException gameOver) {
      this.gameOver = gameOver;
    }

    public void unsetGameOver() {
      this.gameOver = null;
    }

    // Returns true if field gameOver is set (has been asigned a value) and false otherwise
    public boolean isSetGameOver() {
      return this.gameOver != null;
    }

    public void setGameOverIsSet(boolean value) {
      if (!value) {
        this.gameOver = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((LookResults)value);
        }
        break;

      case YOUAREDEAD:
        if (value == null) {
          unsetYouAreDead();
        } else {
          setYouAreDead((YouAreDeadException)value);
        }
        break;

      case GAMEOVER:
        if (value == null) {
          unsetGameOver();
        } else {
          setGameOver((GameOverException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case YOUAREDEAD:
        return getYouAreDead();

      case GAMEOVER:
        return getGameOver();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case YOUAREDEAD:
        return isSetYouAreDead();
      case GAMEOVER:
        return isSetGameOver();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof look_result)
        return this.equals((look_result)that);
      return false;
    }

    public boolean equals(look_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_youAreDead = true && this.isSetYouAreDead();
      boolean that_present_youAreDead = true && that.isSetYouAreDead();
      if (this_present_youAreDead || that_present_youAreDead) {
        if (!(this_present_youAreDead && that_present_youAreDead))
          return false;
        if (!this.youAreDead.equals(that.youAreDead))
          return false;
      }

      boolean this_present_gameOver = true && this.isSetGameOver();
      boolean that_present_gameOver = true && that.isSetGameOver();
      if (this_present_gameOver || that_present_gameOver) {
        if (!(this_present_gameOver && that_present_gameOver))
          return false;
        if (!this.gameOver.equals(that.gameOver))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new LookResults();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case YOUAREDEAD:
            if (field.type == TType.STRUCT) {
              this.youAreDead = new YouAreDeadException();
              this.youAreDead.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GAMEOVER:
            if (field.type == TType.STRUCT) {
              this.gameOver = new GameOverException();
              this.gameOver.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetGameOver()) {
        oprot.writeFieldBegin(GAME_OVER_FIELD_DESC);
        this.gameOver.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetYouAreDead()) {
        oprot.writeFieldBegin(YOU_ARE_DEAD_FIELD_DESC);
        this.youAreDead.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("look_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("youAreDead:");
      if (this.youAreDead == null) {
        sb.append("null");
      } else {
        sb.append(this.youAreDead);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("gameOver:");
      if (this.gameOver == null) {
        sb.append("null");
      } else {
        sb.append(this.gameOver);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class grow_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("grow_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(grow_args.class, metaDataMap);
    }

    public grow_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grow_args(grow_args other) {
    }

    @Override
    public grow_args clone() {
      return new grow_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof grow_args)
        return this.equals((grow_args)that);
      return false;
    }

    public boolean equals(grow_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("grow_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class grow_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("grow_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField YOU_ARE_DEAD_FIELD_DESC = new TField("youAreDead", TType.STRUCT, (short)-1);
    private static final TField GAME_OVER_FIELD_DESC = new TField("gameOver", TType.STRUCT, (short)-2);

    public GrowResults success;
    public static final int SUCCESS = 0;
    public YouAreDeadException youAreDead;
    public static final int YOUAREDEAD = -1;
    public GameOverException gameOver;
    public static final int GAMEOVER = -2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GrowResults.class)));
      put(YOUAREDEAD, new FieldMetaData("youAreDead", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(GAMEOVER, new FieldMetaData("gameOver", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(grow_result.class, metaDataMap);
    }

    public grow_result() {
    }

    public grow_result(
      GrowResults success,
      YouAreDeadException youAreDead,
      GameOverException gameOver)
    {
      this();
      this.success = success;
      this.youAreDead = youAreDead;
      this.gameOver = gameOver;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grow_result(grow_result other) {
      if (other.isSetSuccess()) {
        this.success = new GrowResults(other.success);
      }
      if (other.isSetYouAreDead()) {
        this.youAreDead = new YouAreDeadException(other.youAreDead);
      }
      if (other.isSetGameOver()) {
        this.gameOver = new GameOverException(other.gameOver);
      }
    }

    @Override
    public grow_result clone() {
      return new grow_result(this);
    }

    public GrowResults getSuccess() {
      return this.success;
    }

    public void setSuccess(GrowResults success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public YouAreDeadException getYouAreDead() {
      return this.youAreDead;
    }

    public void setYouAreDead(YouAreDeadException youAreDead) {
      this.youAreDead = youAreDead;
    }

    public void unsetYouAreDead() {
      this.youAreDead = null;
    }

    // Returns true if field youAreDead is set (has been asigned a value) and false otherwise
    public boolean isSetYouAreDead() {
      return this.youAreDead != null;
    }

    public void setYouAreDeadIsSet(boolean value) {
      if (!value) {
        this.youAreDead = null;
      }
    }

    public GameOverException getGameOver() {
      return this.gameOver;
    }

    public void setGameOver(GameOverException gameOver) {
      this.gameOver = gameOver;
    }

    public void unsetGameOver() {
      this.gameOver = null;
    }

    // Returns true if field gameOver is set (has been asigned a value) and false otherwise
    public boolean isSetGameOver() {
      return this.gameOver != null;
    }

    public void setGameOverIsSet(boolean value) {
      if (!value) {
        this.gameOver = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GrowResults)value);
        }
        break;

      case YOUAREDEAD:
        if (value == null) {
          unsetYouAreDead();
        } else {
          setYouAreDead((YouAreDeadException)value);
        }
        break;

      case GAMEOVER:
        if (value == null) {
          unsetGameOver();
        } else {
          setGameOver((GameOverException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case YOUAREDEAD:
        return getYouAreDead();

      case GAMEOVER:
        return getGameOver();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case YOUAREDEAD:
        return isSetYouAreDead();
      case GAMEOVER:
        return isSetGameOver();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof grow_result)
        return this.equals((grow_result)that);
      return false;
    }

    public boolean equals(grow_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_youAreDead = true && this.isSetYouAreDead();
      boolean that_present_youAreDead = true && that.isSetYouAreDead();
      if (this_present_youAreDead || that_present_youAreDead) {
        if (!(this_present_youAreDead && that_present_youAreDead))
          return false;
        if (!this.youAreDead.equals(that.youAreDead))
          return false;
      }

      boolean this_present_gameOver = true && this.isSetGameOver();
      boolean that_present_gameOver = true && that.isSetGameOver();
      if (this_present_gameOver || that_present_gameOver) {
        if (!(this_present_gameOver && that_present_gameOver))
          return false;
        if (!this.gameOver.equals(that.gameOver))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GrowResults();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case YOUAREDEAD:
            if (field.type == TType.STRUCT) {
              this.youAreDead = new YouAreDeadException();
              this.youAreDead.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GAMEOVER:
            if (field.type == TType.STRUCT) {
              this.gameOver = new GameOverException();
              this.gameOver.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetGameOver()) {
        oprot.writeFieldBegin(GAME_OVER_FIELD_DESC);
        this.gameOver.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetYouAreDead()) {
        oprot.writeFieldBegin(YOU_ARE_DEAD_FIELD_DESC);
        this.youAreDead.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("grow_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("youAreDead:");
      if (this.youAreDead == null) {
        sb.append("null");
      } else {
        sb.append(this.youAreDead);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("gameOver:");
      if (this.gameOver == null) {
        sb.append("null");
      } else {
        sb.append(this.gameOver);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class move_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("move_args");
    private static final TField DIRECTION_FIELD_DESC = new TField("direction", TType.I32, (short)-1);

    public int direction;
    public static final int DIRECTION = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean direction = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(DIRECTION, new FieldMetaData("direction", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(move_args.class, metaDataMap);
    }

    public move_args() {
    }

    public move_args(
      int direction)
    {
      this();
      this.direction = direction;
      this.__isset.direction = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public move_args(move_args other) {
      __isset.direction = other.__isset.direction;
      this.direction = other.direction;
    }

    @Override
    public move_args clone() {
      return new move_args(this);
    }

    public int getDirection() {
      return this.direction;
    }

    public void setDirection(int direction) {
      this.direction = direction;
      this.__isset.direction = true;
    }

    public void unsetDirection() {
      this.__isset.direction = false;
    }

    // Returns true if field direction is set (has been asigned a value) and false otherwise
    public boolean isSetDirection() {
      return this.__isset.direction;
    }

    public void setDirectionIsSet(boolean value) {
      this.__isset.direction = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case DIRECTION:
        if (value == null) {
          unsetDirection();
        } else {
          setDirection((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case DIRECTION:
        return getDirection();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case DIRECTION:
        return isSetDirection();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof move_args)
        return this.equals((move_args)that);
      return false;
    }

    public boolean equals(move_args that) {
      if (that == null)
        return false;

      boolean this_present_direction = true;
      boolean that_present_direction = true;
      if (this_present_direction || that_present_direction) {
        if (!(this_present_direction && that_present_direction))
          return false;
        if (this.direction != that.direction)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case DIRECTION:
            if (field.type == TType.I32) {
              this.direction = iprot.readI32();
              this.__isset.direction = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(DIRECTION_FIELD_DESC);
      oprot.writeI32(this.direction);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("move_args(");
      boolean first = true;

      sb.append("direction:");
      String direction_name = Direction.VALUES_TO_NAMES.get(this.direction);
      if (direction_name != null) {
        sb.append(direction_name);
        sb.append(" (");
      }
      sb.append(this.direction);
      if (direction_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
      if (isSetDirection() && !Direction.VALID_VALUES.contains(direction)){
        throw new TProtocolException("The field 'direction' has been assigned the invalid value " + direction);
      }
    }

  }

  public static class move_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("move_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField YOU_ARE_DEAD_FIELD_DESC = new TField("youAreDead", TType.STRUCT, (short)-1);
    private static final TField GAME_OVER_FIELD_DESC = new TField("gameOver", TType.STRUCT, (short)-2);

    public MoveResults success;
    public static final int SUCCESS = 0;
    public YouAreDeadException youAreDead;
    public static final int YOUAREDEAD = -1;
    public GameOverException gameOver;
    public static final int GAMEOVER = -2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MoveResults.class)));
      put(YOUAREDEAD, new FieldMetaData("youAreDead", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(GAMEOVER, new FieldMetaData("gameOver", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(move_result.class, metaDataMap);
    }

    public move_result() {
    }

    public move_result(
      MoveResults success,
      YouAreDeadException youAreDead,
      GameOverException gameOver)
    {
      this();
      this.success = success;
      this.youAreDead = youAreDead;
      this.gameOver = gameOver;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public move_result(move_result other) {
      if (other.isSetSuccess()) {
        this.success = new MoveResults(other.success);
      }
      if (other.isSetYouAreDead()) {
        this.youAreDead = new YouAreDeadException(other.youAreDead);
      }
      if (other.isSetGameOver()) {
        this.gameOver = new GameOverException(other.gameOver);
      }
    }

    @Override
    public move_result clone() {
      return new move_result(this);
    }

    public MoveResults getSuccess() {
      return this.success;
    }

    public void setSuccess(MoveResults success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public YouAreDeadException getYouAreDead() {
      return this.youAreDead;
    }

    public void setYouAreDead(YouAreDeadException youAreDead) {
      this.youAreDead = youAreDead;
    }

    public void unsetYouAreDead() {
      this.youAreDead = null;
    }

    // Returns true if field youAreDead is set (has been asigned a value) and false otherwise
    public boolean isSetYouAreDead() {
      return this.youAreDead != null;
    }

    public void setYouAreDeadIsSet(boolean value) {
      if (!value) {
        this.youAreDead = null;
      }
    }

    public GameOverException getGameOver() {
      return this.gameOver;
    }

    public void setGameOver(GameOverException gameOver) {
      this.gameOver = gameOver;
    }

    public void unsetGameOver() {
      this.gameOver = null;
    }

    // Returns true if field gameOver is set (has been asigned a value) and false otherwise
    public boolean isSetGameOver() {
      return this.gameOver != null;
    }

    public void setGameOverIsSet(boolean value) {
      if (!value) {
        this.gameOver = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((MoveResults)value);
        }
        break;

      case YOUAREDEAD:
        if (value == null) {
          unsetYouAreDead();
        } else {
          setYouAreDead((YouAreDeadException)value);
        }
        break;

      case GAMEOVER:
        if (value == null) {
          unsetGameOver();
        } else {
          setGameOver((GameOverException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case YOUAREDEAD:
        return getYouAreDead();

      case GAMEOVER:
        return getGameOver();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case YOUAREDEAD:
        return isSetYouAreDead();
      case GAMEOVER:
        return isSetGameOver();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof move_result)
        return this.equals((move_result)that);
      return false;
    }

    public boolean equals(move_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_youAreDead = true && this.isSetYouAreDead();
      boolean that_present_youAreDead = true && that.isSetYouAreDead();
      if (this_present_youAreDead || that_present_youAreDead) {
        if (!(this_present_youAreDead && that_present_youAreDead))
          return false;
        if (!this.youAreDead.equals(that.youAreDead))
          return false;
      }

      boolean this_present_gameOver = true && this.isSetGameOver();
      boolean that_present_gameOver = true && that.isSetGameOver();
      if (this_present_gameOver || that_present_gameOver) {
        if (!(this_present_gameOver && that_present_gameOver))
          return false;
        if (!this.gameOver.equals(that.gameOver))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new MoveResults();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case YOUAREDEAD:
            if (field.type == TType.STRUCT) {
              this.youAreDead = new YouAreDeadException();
              this.youAreDead.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GAMEOVER:
            if (field.type == TType.STRUCT) {
              this.gameOver = new GameOverException();
              this.gameOver.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetGameOver()) {
        oprot.writeFieldBegin(GAME_OVER_FIELD_DESC);
        this.gameOver.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetYouAreDead()) {
        oprot.writeFieldBegin(YOU_ARE_DEAD_FIELD_DESC);
        this.youAreDead.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("move_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("youAreDead:");
      if (this.youAreDead == null) {
        sb.append("null");
      } else {
        sb.append(this.youAreDead);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("gameOver:");
      if (this.gameOver == null) {
        sb.append("null");
      } else {
        sb.append(this.gameOver);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
